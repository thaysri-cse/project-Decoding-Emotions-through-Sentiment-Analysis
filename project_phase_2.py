# -*- coding: utf-8 -*-
"""Project_Phase 2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13MRVCJmD06br2jqPcfTDWXDP4-3i9iXP

Upload the dataset
"""

from google.colab import files
uploaded = files.upload()

"""Load the Dataset"""

import pandas as pd

# Read the dataset
df = pd.read_csv('trainer_schedule_report.csv',sep=';')

"""Data Exploration"""

# Display first few rows
df.head()

"""Check for Missing Values and Duplicates"""

#Check for missing values
print(df.isnull().sum())

# Check for duplicates
print("Duplicate rows:",df.duplicated().sum())

"""Visualize a Few Features"""

from textblob import TextBlob
import matplotlib.pyplot as plt

# Example social media texts
posts = [
    "I love sunny days!",
    "I'm so tired of this traffic.",
    "Today is just okay.",
    "Feeling excited about the trip!",
    "This app keeps crashing. Terrible experience."
]

# Count of each sentiment
sentiment_count = {"Positive": 0, "Negative": 0, "Neutral": 0}

# Function to classify sentiment
def get_sentiment(text):
    polarity = TextBlob(text).sentiment.polarity
    if polarity > 0:
        return "Positive"
    elif polarity < 0:
        return "Negative"
    else:
        return "Neutral"

# Analyze each post
for post in posts:
    sentiment = get_sentiment(post)
    sentiment_count[sentiment] += 1
    print(f"{post} -> {sentiment}")

# Plot results
plt.bar(sentiment_count.keys(), sentiment_count.values(), color=['green', 'red', 'gray'])
plt.title("Sentiment Distribution")
plt.xlabel("Sentiment")
plt.ylabel("Number of Posts")
plt.show()

"""Identify Target and Features"""

from textblob import TextBlob

# Sample social media posts
posts = [
    "I love this new phone! It's amazing ðŸ˜",
    "I'm so tired of this, everything is going wrong ðŸ˜”",
    "What a beautiful day, the sun is shining ðŸŒž",
    "This is terrible, I can't believe it! ðŸ˜¡"
]

# Function to decode emotions
def decode_emotions(posts):
    for post in posts:
        # Create a TextBlob object
        blob = TextBlob(post)

        # Get sentiment polarity (-1 to 1)
        sentiment = blob.sentiment.polarity

        # Classify sentiment into categories
        if sentiment > 0:
            emotion = 'Positive'
        elif sentiment < 0:
            emotion = 'Negative'
        else:
            emotion = 'Neutral'

        print(f"Post: {post}\nEmotion: {emotion}\nPolarity: {sentiment}\n")

# Run the sentiment analysis
decode_emotions(posts)

"""Convert Categorical Columns to Numerical"""

import pandas as pd
from sklearn.preprocessing import LabelEncoder

# Sample dataset (social media posts and their sentiments)
data = {
    'Post': [
        "I love this phone! It's amazing ðŸ˜",
        "I'm so tired of this, everything is bad ðŸ˜ž",
        "What a beautiful day ðŸŒž",
        "This is horrible! ðŸ˜¡"
    ],
    'Sentiment': ['Positive', 'Negative', 'Neutral', 'Negative']
}

# Convert to DataFrame
df = pd.DataFrame(data)

# Initialize LabelEncoder
label_encoder = LabelEncoder()

# Convert categorical 'Sentiment' column to numerical values
df['Sentiment_Numerical'] = label_encoder.fit_transform(df['Sentiment'])

# Show the transformed DataFrame
print(df)

"""One-Hot Encoding"""

import pandas as pd

# Sample data: social media posts and their emotion labels
data = {
    'Post': [
        "This party is awesome! ðŸŽ‰",
        "I can't take this anymore... ðŸ˜¡",
        "Feeling down today. Nothing's going right ðŸ˜¢",
        "Such a peaceful evening ðŸ˜Š"
    ],
    'Emotion': ['Happy', 'Angry', 'Sad', 'Happy']
}

# Convert to DataFrame
df = pd.DataFrame(data)

# One-Hot Encode the 'Emotion' column
df_encoded = pd.get_dummies(df, columns=['Emotion'], prefix='Emotion')

# Print the result
print(df_encoded)

"""Feature Scaling"""

!pip install scikit-learn pandas
from sklearn.preprocessing import StandardScaler
import numpy as np # this import is for illustrative purposes

# Assume tfidf_array contains your features; replace with your actual data
# The code below creates a sample array, you will need to replace this with your data
tfidf_array = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])

scaler = StandardScaler()
scaled_features = scaler.fit_transform(tfidf_array)

"""Train-Test Split"""

import pandas as pd
from sklearn.model_selection import train_test_split

# Assuming 'socialmedia_data.csv' contains your data with 'text' and 'emotion' columns
# If the file has a different name, change it here
try:
    data = pd.read_csv('socialmedia_data.csv')
except FileNotFoundError:
    print("Error: 'socialmedia_data.csv' not found. Please make sure the file is in the correct directory or upload it.")
    # If the file needs to be uploaded, you can use:
    # from google.colab import files
    # uploaded = files.upload()
    # Then adjust the filename in pd.read_csv accordingly
else:
    X_train, X_test, y_train, y_test = train_test_split(data['text'], data['emotion'], test_size=0.2, random_state=42)

"""Model Building"""

from sklearn.model_selection import train_test_split
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.naive_bayes import MultinomialNB

texts = ["I am happy", "I feel sad", "I'm so excited", "This is frustrating"]
labels = ["happy", "sad", "happy", "angry"]

X_train, X_test, y_train, y_test = train_test_split(texts, labels)
vec = CountVectorizer()
X_train_vec = vec.fit_transform(X_train)
model = MultinomialNB()
model.fit(X_train_vec, y_train)

"""Evaluation"""

from textblob import TextBlob

# Example social media posts
tweets = [
    "I love the new phone update! So smooth and fast. ðŸ˜",
    "Why does this app crash all the time? So annoying! ðŸ˜¡",
    "Just another day, nothing special.",
    "Feeling grateful for all the good things today. ðŸ˜Š",
    "I'm tired of all the negativity in the news."
]

def analyze_sentiment(text):
    blob = TextBlob(text)
    polarity = blob.sentiment.polarity

    if polarity > 0:
        return "Positive"
    elif polarity < 0:
        return "Negative"
    else:
        return "Neutral"

print("Tweet Sentiment Analysis:\n")
for tweet in tweets:
    sentiment = analyze_sentiment(tweet)
    print(f"Tweet: {tweet}\nSentiment: {sentiment}\n")

"""Make Predictions from New Input"""

new_text = ["I can't stop smiling today!", "I'm really upset with everything"]
new_vec = vec.transform(new_text)
predictions = model.predict(new_vec)
print(predictions)

"""Convert to DataFrame and Encode"""

import pandas as pd
from sklearn.preprocessing import LabelEncoder

# Sample data
texts = ["I am happy", "I feel sad", "I'm so excited", "This is frustrating"]
emotions = ["happy", "sad", "happy", "angry"]

# Convert to DataFrame
df = pd.DataFrame({'text': texts, 'emotion': emotions})

# Encode emotions
encoder = LabelEncoder()
df['emotion_encoded'] = encoder.fit_transform(df['emotion'])

print(df)

"""Predict the Final Grade"""

from sklearn.preprocessing import LabelEncoder

# Encode labels (if not already done)
encoder = LabelEncoder()
y_train_enc = encoder.fit_transform(y_train)
model.fit(X_train_vec, y_train_enc)

# Predict on new input
new_text = ["I don't know what to feel, it's overwhelming"]
new_vec = vec.transform(new_text)
pred_encoded = model.predict(new_vec)
pred_label = encoder.inverse_transform(pred_encoded)

print("Predicted Emotion:", pred_label[0])

"""Deployment-Building an Interactive App"""

!pip install gradio

"""Create a Prediction Function"""

def predict_emotion(text):
    vec_input = vec.transform([text])
    pred_encoded = model.predict(vec_input)
    return encoder.inverse_transform(pred_encoded)[0]

# Example use
print(predict_emotion("I am feeling wonderful today!"))

"""Create the Gradio Interface"""

import gradio as gr

# Define the function to predict emotion
def predict_emotion(text):
    vec_input = vec.transform([text])
    pred_encoded = model.predict(vec_input)
    return encoder.inverse_transform(pred_encoded)[0]

# Create Gradio Interface
iface = gr.Interface(fn=predict_emotion,
                     inputs="text",
                     outputs="text",
                     live=True,
                     title="Emotion Decoding from Social Media Text",
                     description="Enter a social media text to predict its emotion.")

# Launch the interface
iface.launch()